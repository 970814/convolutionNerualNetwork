function [z] = nnConvolution(a,w)
%    支持单张单通道数据    与     单个2d卷积核    进行卷积操作
%    支持单张多通道数据    与     单个3d卷积核    进行卷积操作
%    支持多张多通道数据    与     单个3d卷积核    进行卷积操作

%    cnn的多维卷积操作

%    a 是一个h*w*c*m 的多维数组，对于图片，h*w为图片大小，c为图片通道数量,m 为图片数量
%    w 是卷积核，是一个x*y*c的多维数组，x*y为卷积核大小（局部接受视野），c为通道数量
%    a和w的通道数量需要匹配
%    产生的结果是一个(h-x+1 * w-y+1)*1*m 的矩阵
%    步幅为1


%    该算法为下面算法的快速写法，本来3-4层的卷积操作将耗费6.5s，经过修改，现在只需要210ms，详细参考 [反向传播算法-卷积算法优化后-算法耗费时间.txt] 文件
    C = size(a,3);
    C2 = size(w,3);
    if C2 ~= C,
        disp(sprintf('卷积核的通道数必须与输入的通道数相同 %d!=%d',C2,C));
    else
        wt=[];
        %    还需要将w的每片的顺序反过来
        for  j = 1:C,
            %    这里依然存在一个问题，对于3d卷积，考虑第三维度a1,...,ai,...,aj,...,ak,...an  与 w1...,wi,...,wj,...,wk,...wn,  的卷积
            %    产生的结果是 a1 * wn+ ...+ ai * wk+ ...+ aj * wj + ...+ ak * wi+ ...+an * w1,
            %   而我们期待的是a1 * w1+ ...+ ai * wi+ ...+ aj * wj + ...+ ak * wk+... + an * wn,
            wt(:,:,j) = w(:,:,C-j+1);
        end;
%        多张多通道数据 与 单个3d卷积核 的快速卷积操作
        z = convn(a,rot90(wt,2),'valid');
    end;


%%    C2与C必须相等
%    if C2 ~= C,
%        disp(sprintf('卷积核的通道数必须与输入的通道数相同 %d!=%d',C2,C));
%    else
%        z = zeros(H-H2+1,W-W2+1,1,M);
%        for k =1:M,
%%          产生的结果是二维的
%            for j = 1:C,
%                z(:,:,1,k) = z(:,:,1,k) .+ conv2(a(:,:,j,k),rot90(w(:,:,j),2),'valid');
%            end;
%        end;
%    end;

end;

